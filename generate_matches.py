# This script generates auto-generated `matches/-generted-*.yml` files
# using the data from the Unicode Character Database.
# It downloads the latest `UnicodeData.txt` file from the Unicode website
# if it's not already present in the directory.

from dataclasses import dataclass
from os import path
from urllib import request
from collections import defaultdict
import re


UNICODE_DATA_FILE = 'UnicodeData.txt'
UNICODE_DATA_URL = f'https://unicode.org/Public/UCD/latest/ucd/{UNICODE_DATA_FILE}'

DECOMPOSITION_REGEX = r'(?:<(?P<type>[a-zA-Z]+)>)?(?P<codes>[ 0-9A-F]*)'

ESCAPE_RANGES = [(0x00, 0x20), (0x7F, 0xA0), (0xD800, 0xE000), (0xFFFE, 0x10000)]


@dataclass
class EspansoMatch:
    trigger: str
    replace: str
    label: str | None = None

@dataclass
class MatchGroup:
    name: str
    matches: list[EspansoMatch]

@dataclass
class MatchFile:
    name: str
    groups: list[MatchGroup]


class Charachter:
    """ Represents a Unicode character with its properties. """
    def __init__(self, line: str):
        values = line.split(';')
        decomp_match = re.fullmatch(DECOMPOSITION_REGEX, values[5])
        assert(decomp_match)
        decomp_type = decomp_match.group('type')
        decomp_codes = decomp_match.group('codes').split(' ')
        
        self.code = int(values[0], 16)
        self.char = chr(self.code)
        self.name = values[1]
        self.general_category = values[2]
        self.canonical_combining_class = int(values[3])
        self.bidi_class = values[4]
        self.decomposition_type = decomp_type if isinstance(decomp_type, str) else ''
        self.decomposition_mapping = [int(code, 16) for code in decomp_codes if code]
        self.numeric_decimal_value = values[6]
        self.numeric_digit_value = values[7]
        self.numeric_numeric_value = values[8]
        self.bidi_mirrored = values[9] == 'Y'
        self.unicode_1_name = values[10]
        self.iso_comment = values[11]
        self.simple_uppercase_mapping = int(values[12], 16) if values[12] else None
        self.simple_lowercase_mapping = int(values[13], 16) if values[13] else None
        self.simple_titlecase_mapping = int(values[14], 16) if values[14] else None
    
    def __repr__(self) -> str:
        return f'U+{self.code:04x} `{self.char}` {self.name}'


def get_unicode_characters() -> dict[int, Charachter]:
    """ Returns all Unicode charactes from the `UnicodeData.txt` file,
        which is downloaded from the Unicode website if absent.
    """
    if not path.isfile(UNICODE_DATA_FILE):
        print('Downloading Unicode data...')
        request.urlretrieve(UNICODE_DATA_URL, UNICODE_DATA_FILE)
    
    characters = dict()
    with open(UNICODE_DATA_FILE, 'r') as unicode_data:
        while line := unicode_data.readline():
            character = Charachter(line.strip('\n'))
            characters[character.code] = character
    
    return characters


def generate_yaml(match_file: MatchFile, compact: bool=True) -> None:
    """ Writes match groups into a yaml file.
        Not using `pyyaml` to avoid dependencies.
    """
    if compact:
        prefix, separator, postfix = '- { ',  ', ',  ' }\n'
    else:
        prefix, separator, postfix = '  - ',  '\n    ',  '\n\n'

    def escape(character: str) -> str:
        if character in r'\"':       # yaml escaping:
            return rf'\{character}'  # single slash
        if character in r'[]{}':     # Espanso escaping + yaml escaping:
            return rf'\\{character}' # two slashes
        code = ord(character)
        for start, end in ESCAPE_RANGES:
            if start <= code < end:
                return rf'\u{code:04x}'
        return character
    
    def field(name: str, value: str) -> str:
        escaped_value = ''.join(escape(c) for c in value)
        return f'{name}: "{escaped_value}"'
    
    filename = f'matches/-generated-{match_file.name}.yml'
    with open(filename, 'w') as file:
        file.write('# This file is auto-generated by `generate_matches.py`\n')
        file.write('matches:\n')
        for group in match_file.groups:
            file.write(f'\n# {group.name}\n')
            for match in group.matches:
                fields = [
                    field('trigger', match.trigger),
                    field('replace', match.replace),
                ]
                if match.label is not None:
                    fields.append(field('label', match.label))
                
                file.write(f'{prefix}{separator.join(fields)}{postfix}')


if __name__ == '__main__':
    print('Generating auto-generated match files...')
    
    unicode_characters = get_unicode_characters()
    by_name = { c.name: c for c in unicode_characters.values() }

    def get_decomp_group(name: str, actuator: str, decomposition_type: str, name_regex: str='', replace: str='', with_: str='') -> MatchGroup:
        """ Creates a group of matches from all the Unicode characters with
            the given decomposition type and names matching the given regex.
        """
        matches = []
        for c in unicode_characters.values():
            if c.decomposition_type == decomposition_type and re.match(name_regex, c.name):
                decomposed = ''.join(chr(code) for code in c.decomposition_mapping)
                if replace:
                    decomposed = decomposed.replace(replace, with_)
                matches.append(EspansoMatch(decomposed + actuator, c.char, c.name.title()))
        return MatchGroup(name, matches)
    
    def get_name_group(name: str, actuator: str, name_regex: str, replace_pattern: str) -> MatchGroup:
        """ Creates a group of matches from all the Unicode characters with name matching the given regex.
        """
        matches = []
        for c in unicode_characters.values():
            if re.match(name_regex, c.name):
                trigger_name = re.sub(name_regex, replace_pattern, c.name)
                trigger = by_name.get(trigger_name)
                if trigger is not None:
                    matches.append(EspansoMatch(trigger.char + actuator, c.char, c.name.title()))
        return MatchGroup(name, matches)
    
    def get_diacritic_groups(name_regex: str) -> list[MatchGroup]:
        """ Creates groups of matches for every diacritical mark in Unicode
            whose name matches the regex.
        """
        groups: dict[str, list[EspansoMatch]] = defaultdict(list)
        for c in unicode_characters.values():
            if not c.decomposition_type and len(c.decomposition_mapping) == 2:
                diacritic = unicode_characters[c.decomposition_mapping[1]]
                if re.match(name_regex, diacritic.name):
                    decomposed = ''.join(chr(code) for code in c.decomposition_mapping)
                    groups[diacritic.name].append(EspansoMatch(decomposed, c.char, c.name.title()))
        return [MatchGroup(name.title(), matches) for name, matches in groups.items()]
    
    files = [
        MatchFile('super-subscript', [
            get_decomp_group('Superscript',   '⤒', 'super', r'^(SUPERSCRIPT|MODIFIER LETTER) '),
            get_decomp_group('Subscript',     '⤓', 'sub'),
        ]),
        MatchFile('fancy-fonts', [
            get_decomp_group('Double-struck', '‖', 'font', r'^(MATHEMATICAL )?DOUBLE-STRUCK '),
            get_decomp_group('Script',        '⅏', 'font', r'^(MATHEMATICAL )?SCRIPT '),
            get_decomp_group('Fraktur',       '■', 'font', r'^(MATHEMATICAL FRAKTUR|BLACK-LETTER) '),
            get_decomp_group('Segmented',     '⌓', 'font', r'^SEGMENTED '),
            get_decomp_group('Circled',       '⃝', 'circle', r'^CIRCLED (DIGIT|LATIN) '),
        ]),
        MatchFile('ligatures', [
            get_decomp_group('Armenian',      '⁀', 'compat', r'^ARMENIAN.* LIGATURE '),
            get_decomp_group('Fractions',     '⁀', 'fraction', replace='⁄', with_='/'),
        ]),
        MatchFile('letter-shapes', [
            get_name_group('Small-Caps',      '©', r'^(.*?)(LETTER )?(SMALL )CAPITAL (.*)$', r'\1\3\2\4'),
            get_name_group('Descender',       'ˌ', r'^(.*) WITH DESCENDER$', r'\1'),
            get_name_group('Palatal Hook',    '̡', r'^(.*) WITH PALATAL HOOK$', r'\1'),
            get_name_group('Retroflex Hook',  '̢', r'^(.*) WITH RETROFLEX HOOK$', r'\1'),
            get_name_group('Hook',            '◞', r'^(.*) WITH HOOK$', r'\1'),
            get_name_group('Tail',            '◟', r'^(.*) WITH TAIL$', r'\1'),
            get_name_group('Curl',            '➰', r'^(.*) WITH CURL$', r'\1'),
        ]),
        MatchFile('diacritics', get_diacritic_groups(r'^COMBINING (?!KATAKANA)')),
    ]
    
    for file in files:
        generate_yaml(file)
        print(f'- `{file.name}`')
